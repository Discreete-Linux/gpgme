* ABI's to break:
** The resulting error of an operation can not be retrieved
   seperately; the op_foobar operations can't be implemented
   by the user, they are not merely convenience, but necessity, while
   the op_foobar_start functions for these are unusable (or render the
   context unusable, your choice).
** string representation of non-secret keys and ATTR_IS_SECRET is NULL,
   which can not be differentiated from the case that it is not
   representable.
** keylisting mode can go
** api to specify where to search, lokal and/or remote.

* Implement posix-sema.c

* Allow to use GTK's main loop instead of the select stuff in
  wait.c

* add locking to the key cache?

* GpgmeKey misses GPGME_ATTR_EXPIRE attribute

* Add ATTR to return the number of subkeys or uids.

* Return GPGME_Canceled when appropriate

* Factor out common code in _op_*_start functions.

* Documentation
** Add note about GPGME clearing out pointer return values.
** validity/trust

* Engines
** Move code common to all engines up from gpg to engine.
** engine operations can return General Error on unknown protocol
   (it's an internal error, as select_protocol checks already).

* Operations
** Import, export status handler.
** Should --delete silently delete secret keys or is there a need for
   another flag or a callback?

* Error Values
** Map ASSUAN error values.
** Map GpgSM ERR messages.
** Verify (and document) if Read_Error, Write_Error, Pipe_Error set errno.

* Tests
** t-data
*** Test gpgme_data_release_and_get_mem.
*** Test gpgme_data_rewind for invalid types.
*** Test gpgme_data_read's readable feature.

* Build suite
** Make sure everything is cleaned correctly (esp. test area).

Bugs reported by Stephane Corthesy:
> - When returning a GpgmeKey GPGME_ATTR_COMMENT attribute, characters  
> like ":" are not un-escaped, they are returned as \x3a

> BTW, here's another bug: it it not possible to retrieve fingerprints  
> for subkeys

> In GpgmeRecipients, would it be possible to provide a function which  
> would return the validity assigned to a name contained in the  
> GpgmeRecipients instance?

> - There is an inconsistent behaviour: if we pass three times an  
> invalid (but non empty) passphrase, return code is GPGME_No_Data, but  
> if we pass three times an empty (and invalid) passphrase, we get  
> GPGME_No_Passphrase.

> passphrase callback. If I use the same GpgmeContext as the one which  
> is currently asking for a passphrase, my app crashes: the r_hd in
> the  
> callback has become invalid; if I use a brand new one, the callback  
> is called recursively, when I ask to enumerate keys.

> Talking about gpgme performances: did anyone make some profiling on
> gpgme calls and can tell me why it takes so long to enumerate the
> whole pubring? Listing keys with gpg is very fast, whereas with
> gpgme_op_keylist_XXX() it's soooooo slow.
